.. 
   Copyright 2019 Xilinx, Inc.
  
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
  
       http://www.apache.org/licenses/LICENSE-2.0
  
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

.. _guide-hash-aggregate:

********************************
Internals of Hash-Aggregate
********************************

.. toctree::
   :hidden:
   :maxdepth: 2

This document describes the structure and execution of Hash-Aggregate,
implemented as :ref:`hashAggregate <cid-xf::database::hashAggregate>` function.

.. image:: /images/hash_aggr.png
   :alt: Hash Aggregate Structure
   :width: 80%
   :align: center

The Hash-Aggregate primitive is a PU which designed to utilize the advantage of high memory bandwidth in Xilinx FPGA.
Current design uses 1 input channel though which a pair of key and payload can be passed in each cycle.
When there is more than 1 input channel, Client could duplicate the PU and then again aggregate the result in the host side
to reach the goals.

There are Applicable conditions:

1. The width of hash space is configurable, HASHW can be configured no more than 12 (bit).
   The design can handle no more than 1024(equal to 1<<(HASHW-2)) key distinct cases when the width of hash space is configed at 12 (bit).

2. The data width of combined key and payload is configurable, while sum of them cannot exceed 287 bits in current version.
   Combined key means the combining key of the keys to be gourped-by.

3. There are four functions for calculating the payload. They are MAX, MIN ,SUM, COUNT,
   Each one is represented by input parameter xf::database::AOP_MAX, xf::database::AOP_MIN, xf::database::AOP_SUM,
   xf::database::AOP_COUNT.
   These functions only support for integer types as ap_int<n>, int and so on.

This PU performs Hash-Aggregate in four modules working simultaneously. For example, in a <DATINW, DATOUTW, KINW, HASHW>=<32,32,236,12>
design:

.. image:: /images/hash_aggr_collision.png
   :alt: Hash Aggregate collision
   :width: 80%
   :align: center

1. hash_aggr_main: It takes a pair of Combined key and payload as input, calculate the hash address.
   The keys which first hit their address (about 88%) are aggregated in this module and output to
   hash_aggr_passmain.
   Other keys are spilled to hash_aggr_spill

2. hash_aggr_spill: It takes a pair of Combined key and payload and relative hash value as input.
   The keys which second hit their address (about 11%) are aggregated in this module and output
   to hash_aggr_done.
   Other keys are spilled to hash_aggr_done in the other streams.

3. hash_aggr_passmain: pass the result form the hash_aggr_main, so that the PU could dataflow.

4. hash_aggr_done: finally, the remaining keys (about 1%) are aggregated, and output all the
   aggregate results.

.. CAUTION::
   These Applicable conditions.

This ``hashAggregate`` primitve has only one port for key input and one port for payload input.
If your tables are joined by multiple key columns or has multiple columns as payload,
please use :ref:`combineCol <cid-xf::database::combineCol>` to merge the column streams, and
use :ref:`splitCol <cid-xf::database::splitCol>` to split the output to columns.


.. _L1_FFT_LABEL:

.. toctree::
   :caption: Table of Contents
   :maxdepth: 3


======================================
1-Dimensional(Line) FFT L1 FPGA Module
======================================

.. _FIXED_FFT_PARAMS_STRUCT_LABEL:

Overview
========
XF FFT offers a fully synthesizable Super Sample data Rate (SSR) FFT with a systolic
architecture to process multiple input samples every clock cycle. The number of samples
processed in parallel per cycle is denoted by the SSR factor. The FFT is implemented as a C++
template function that synthesizes into a streaming architecture.The FFT architecture used for implementation can be parametrized through template parameters which are grouped in a C++ struct of type **ssr_fft_default_params**. A new structure can be defined by extending default structure and re-defining required member constants as follows:

.. code-block:: cpp

	struct ssr_fft_fix_params:ssr_fft_default_params
	{
		static const int N = 1024;
		static const int R = 4;
		static const scaling_mode_enum scaling_mode = SSR_FFT_NO_SCALING;
		static const fft_output_order_enum output_data_order = SSR_FFT_NATURAL;
		static const int twiddle_table_word_length = 18;
		static const int twiddle_table_integer_part_length = 2; 
		static const transform_direction_enum transform_direction = FORWARD_TRANSFORM;
		static const butterfly_rnd_mode_enum butterfly_rnd_mode = TRN;
	};

The structure above defines:

- N: Size or length of transform
- R: The number of samples to be processed in parallel SSR Factor and radix of FFT algorithm used
- scaling_mode: The scaling mode as enumeration type, FFT has three different scaling modes
- output_data_order: Output data order which will decided if data will be in natural order or digit reversed transposed order
- twiddle_table_word_length: Defines total number of bits to be used for storing twiddle table factors
- twiddle_table_integer_part_length: The number of integer bit used for storing integer part of twiddles
- transform_direction : Defines of the direction of transform, inverse transform (IFFT) or forward transform (FFT)
- butterfly_rnd_mode : Defines the rounding mode used by butterflies in FFT stages.

.. code-block:: cpp

   xf::dsp::fft::fft<fftParams><ssr_fft_fix_params>(...);

Multi-Instance Support
======================
Current release of XF FFT supports the use multiple instance of 1-D SSR FFT in a single design. To enable the use of multiple instances fft function takes as input a new template parameter besides parameter structure. This parameters gets a default value if user doesn't provides any value for it. But if multiple instance support is required all the instances used should be provided with unique integer template parameter. 

.. code-block:: cpp
   
   xf::dsp::fft::fft<fftParams,1><ssr_fft_fix_params>(...);
   xf::dsp::fft::fft<fftParams,2><ssr_fft_fix_params>(...);



Performance
===========
The FFT throughput (initiation interval) can be calculated as L/R where R is the SSR value and L
is the number of samples to be transformed. The possible values for R (SSR values) are: 2,4,8,16.
These values allow for a Fmax range of **300-550 MHz** when targeting the slowest of UltraScale+
speed-grade devices

Data Type Support for Synthesis
===============================
Currently 1-D SSR FFT supports fixed point and floating point complex inputs for synthesis.

Fixed Point
-----------
The fixed point FFT implementation is based on fixed point data types **std::complex<ap_fixed<>>** which is used for synthesis and implementation. It is possible to use floating point types **std::complex<float>** and **std::complex<double>** for simulation but floating point complex models are not synthesizable.
For the best results with fixed point type, liming the data bit width to 27 bits (integer + fraction) as it helps to map multiplication and addition within FFT butterflies directly onto a single DSP block. Larger inputs can be used but may lead to slower Fmax and more resource utilization. Finally, note that the complex exponential/twiddle factor storage is on 18 bit (16F+2I Bits). The selection of 18-bit is made keeping in view the 18x27 multipliers available within DSP blocks on Xilinx FPGAs.

.. _FLOAT_FFT_PARAMS_STRUCT_LABEL:

Floating Point
--------------
1-D SSR FFT also supports synthesis for single precision floating point type, it may be synthesized for double precision but it has not been tested for it. For synthesizing complex floating point type it is required that std::complex type not to be used as complex wrapper since it has some issues and it is required that a wrapper class provided with XF FFT library called complex_wrapper<...> is used for wrapping complex float numbers.
Also while synthesizing floating point 1-D SSR FFT the parameters in the structure which carries some information like scaling mode , twiddle factor storage bits, butterfly rounding mode etc. related only to fixed point data-path carry no meaning. Instead FFT parameter structure can simply define relevant parameters as defined below:

.. code-block:: cpp

	struct ssr_fft_fix_params:ssr_fft_default_params
	{
		static const int N = 1024;
		static const int R = 4;
		static const fft_output_order_enum output_data_order = SSR_FFT_NATURAL;
		static const transform_direction_enum transform_direction = FORWARD_TRANSFORM;
	};

Managing Bit Growth in FFT Stages
=================================
The bit growth management is required for fixed point implementation only.The FFT supports three diﬀerent modes to manage bit growth between FFT stages. These three modes can be used to allow bit growth in every stage, or use scaling in every stage without any
bit growth, or allow bit growth until 27 bits and then start using scaling. The detailed description for different modes is as follows:

SSR_FFT_GROW_TO_MAX_WIDTH
------------------------------------------------- 
When the scaling_mode constant in the parameter structure is set to SSR_FFT_GROW_TO_MAX_WIDTH, it specifies growth from stage to stage, starting from the first stage to a specified max bit width. The output bit width grows until 27 bits and then saturates. The output bit width grows by log2(R) bits in every stage, and then
maxes outs at 27 bits to keep the butterﬂy operation mapping to DSPs. This option is useful
when the initial input bit width is less than 27 bits.

SSR_FFT_SCALE
-------------
When the scaling_mode constant in the parameter structure is set to SSR_FFT_SCALE, it enables scaling on outputs in every stage. Output is scaled in every stage and loses precision. An FFT with size L and Radix=SSR=R has logR(L) stages. This option is useful when the input bit width is already close to 27 bits and it is required that output does not grow beyond 27 bits to map multiplication to DSPs.

SSR_FFT_NO_SCALE
----------------
When the scaling_mode constant in the parameter structure is set
to SSR_FFT_NO_SCALE, the bit growth is allowed in every stage and the output grows
unbounded by log2(R) in every stage. This setting can be useful when high precision is
required. However, if the output bit width grows beyond 27 bits, the multiplication may not
map to DSPs only, but also start using FPGA fabric logic in combination; this may reduce the
clock speed and increase resource utilization.

Configurations for Fixed Point Implementation (Recommended Flow)
================================================================
1-D SSR FFT supports multiple scaling modes and provides options to define input bit-widths and bit-width required to store exponential values (sin/cos in look-up tables). The signal to noise ratio
that defines the quality of output signal depends on the choice of these diﬀerent parameters and
also on the quantification scheme used for converting real valued continuous signal or ﬂoat point
signal to fixed point. The range and the resolution of the signal, essentially the integer bits and
the fraction bits, should be selected carefully to have good signal-to-noise ratio (SNR) at the
output of the FFT. Following is the recommended ﬂow for working with 1-D SSR FFT HLS IP for fixed point implementation.

Start With Floating Point Model
-------------------------------
Currently, 1-D SSR FFT can be used with ap_fxied<>, ﬂoat, and double types. The following table list
the support for synthesis and simulation.

+------------------------------+---------------------------+----------------------------+
|                              |                           |                            |
|              Type            |                 Synthesis |           Simulation       |
|                              |                           |                            |
+==============================+===========================+============================+                              
|   std::complex <ap_fixed <>> |             YES           |              YES           |
|                              |                           |                            |
+------------------------------+---------------------------+----------------------------+
|                              |                           |                            |
|       std::complex<float>    |              NO           |              YES           |
|                              |                           |                            |
+------------------------------+---------------------------+----------------------------+
|                              |                           |                            |
|      std::complex<double>    |              NO           |              YES           |
|                              |                           |                            |
+------------------------------+---------------------------+----------------------------+
|                              |                           |                            |
|      complex_wrapper<float>  |              NO           |              YES           |
|                              |                           |                            |
+------------------------------+---------------------------+----------------------------+
|                              |                           |                            |
|      complex_wrapper<float>  |              YES          |              YES           |
|                              |                           |                            |
+------------------------------+---------------------------+----------------------------+

The recommended starting point is to start with ﬂoat/double inner type in std::complex<>
and verify the SNR against a reference model, such as the Matlab/Python/Octave/Simulink
whichever modeling language or tool is used by generating golden test vectors. The
synthesizable version of the 1-D SSR FFT currently supports ap_fixed<> and float as inner type, so the next
step in case of fixed point implementation is to start experimenting with a fixed point model.   

Fixed Point Modeling and Implementation
---------------------------------------
Fixed Point Model
^^^^^^^^^^^^^^^^^
Once working with fixed point model, the recommended scaling mode to start is
**SSR_FFT_NO_SCALING**. The input bit-widths should be selected as follows.
Create an initial fixed point model with type **ap_fixed<WL, IL>**. The overall input type is
**std::complex <ap_fixed<WL, IL>**, essentially storing real and imaginary parts of the
input.
The parts are:

- IL: Integer bits, selected based on the input range
- WL: Word Length= IL + FL, where FL is the Fraction Bit Width, selected based on input resolution

In this case, 1-D SSR FFT internally does not use any scaling because of scaling mode selection;
therefore, no potential scaling errors will be seen at the output. With scaling mode set to no
scaling, you can experiment with other fixed point parameters such as integer bits and fraction
bits used to represent the input samples. The simplistic approach would be to select bits required
to represent the input based on the input range and resolution but depending on the other input
characteristic user can optimize these bit widths.

Selecting Bit Widths for Inputs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The selection of input bit width depends on the input data characteristics and the required
resolution, and is a data-dependent choice essentially depending on range and resolution of the
test data. For simulation purposes, you can select an arbitrarily large number of bits for
representing integer and fraction bits. For implementation, you must make an optimal choice
keeping in mind the required SNR.
The recommended strategy is to do the following:

- Keep the scaling mode fixed to SSR_FFT_NO_SCALING.
- Change the input bits for integer and fraction representation by observing the signal to noise ratio at the output of 1-D SSR FFT.
- Reduce the bit widths such that the output SNR requirement is met by the minimum required bits.

Once the SNR requirements are met, you can proceed to other fixed point optimizations, such as
bits required to store complex exponential tables and 1-D SSR FFT output scaling options.

Twiddle Factor or Sine/Cosine Lookup Table Quantization
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
You can change the number of bits used to quantize the sin/cos table (twiddle factors/complex
exponential). The recommended setting is total 18 bits and 2 bits for the fraction. This setting
ensures that during multiplication, the twiddle/sin/cos input can map to the 18-bit input of the
DSP block in Xilinx® FPGAs. The model can synthesize and work for other large bit widths, but
performance might be worse because of multiplication operations not mapping to a single DSP
block and being implemented using multiple DSP blocks and/or FPGA fabric.
The twiddle factor width reduction can be useful when the initial setting for twiddle factor
storage is larger than 18 bits. By default, it is set to use 18 bits with 2 bits reserved for the signed
integer part. The 2 bits are essentially needed to accurately represent a range of number from +1 to -1 (for sin/cos) value in the table.

Choosing the Best Scaling Mode
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
After the choice for input bit width and twiddle factors is made with no scaling, which gives
acceptable SNR or root mean square (RMS) error at the output of fixed point 1-D SSR FFT, you can
start to experiment with the choice of scaling modes. Three different scaling modes are available
with 1-D SSR FFT. The recommended strategy is to start with SSR_FFT_NO_SCALING. If there is an
acceptable SNR/RMS error at the output, switch to SSR_FFT_GROW_TO_MAX_WIDTH. If there is
still an acceptable SNR/RMS error, switch to SSR_FFT_SCALE and observe the SNR/RMS again if it is acceptable keep using SSR_FFT_SCALE otherwise revert back to other mode which gives acceptable SNR/RMS error at the output.

SSR_FFT_NO_SCALING
^^^^^^^^^^^^^^^^^^
This is the recommended mode to start with. It performs no scaling but the output bit width
grows in every stage by log2(R=SSR). For example, if the size of FFT is N=64 and SSR=R=4 is
selected, then 1-D SSR FFT has log4 (64) = 3 stages. If the input bit width is W, the output bit width is
W+3*2=W+6. Therefore, the output would have grown by logR(N)*log2(R) bits.
SSR_FFT_NO_SCALING preserves the accuracy of the computation, but at maximum hardware
cost. The 1-D SSR FFT computation is done in stages with one stage feeding the next stage, so
essentially it is chain of stages.
One of the downfalls of uncontrolled bit growth is that at some point, in a certain stage when
output widths of one stage increases beyond a limit where multiplication operation cannot map to DSP
blocks on the FPGA, the design performance in terms of speed may fall considerably. For
example, for a given design with logR(N) * log2(R) + Input Bit Width(IL+FL) > max(DSP
Block Multiplier Inputs), you might consider using one of the other two available scaling
schemes. For Xilinx DSP48 blocks with 18x27 multipliers for FPGA devices with DSP48 blocks,
the condition will be logR(N) * log2(R) + Input Bit Width > 27.

SSR_FFT_GROW_TO_MAX_WIDTH
^^^^^^^^^^^^^^^^^^^^^^^^^
In this mode, a hybrid approach is used. Initially the bit growth is allowed if there is any room for
growth. If in the starting FFT stages, the output bit-widths are smaller than what can be mapped
to DSP blocks, it allows the bit growth. When the bit width grows beyond what can be mapped
to DSP blocks, it will start scaling the output.

SSR_FFT_SCALE
^^^^^^^^^^^^^
When you know that for a given 1-D FFT size N and SSR factor, the output will grow beyond a limit
which DSP multiplier blocks cannot handle on a given FPGA device, you have the option to set
the scaling on for every stage by selecting the SSR_FFT_SCALE option. This option scales the
output in every stage by right shifting the output by log2 (SSR=R) in every stage.
The recommended flow only provides a guideline for creating a fixed point model and discusses
options available for it in 1-D SSR FFT. Depending on the design SNR/RMS requirements the user is
required to carefully select all these parameters keeping in view different performance and
SNR/RMS requirements for given application.

1-D SSR FFT Library Usage
=========================
Following sections describe how to use XF FFT Library.

Fixed Point 1-D SSR FFT Usage
-----------------------------
The XF 1-D FFT L1 module can be used in a C++ HLS design by:
1- cloning the XF FFT Library git repository and add the following path to compiler include path:

         ``REPO_PATH/xf_fft/L1/include/hw/xf_fft/fixed/``

2- Include ``xf_fft.hpp``

3- Use namespace ``xf::dsp::fft``

4- Define fft parameter structure say call it ``params_fix`` by extending ``ssr_fft_default_params`` like :ref:`Defining 1-D FFT Parameter Structure <FIXED_FFT_PARAMS_STRUCT_LABEL>`

5- call ``fft<params_fix>(input_array,output_array)``

Following section gives usage examples and explains some other interface level details for use in C++ based
HLS design.
To use the 1-D SSR FFT L1 module:

1. Include the ``xf_fft.hpp`` header:


.. code-block:: cpp

  #include "xf_fft.hpp.h"

2. Use namespace ``xf::dsp::fft``

.. code-block:: cpp

   using namespace xf::dsp::fft;

3. Define a C++ structure that extends ``ssr_fft_default_params``:

.. code-block:: cpp

	struct params_fix:ssr_fft_default_params
	{
		static const int N-SSR_FFT_L;
		static const int R=SSR_FFT_R;
		static const scaling_mode_enum
		scaling_mode=SSR_FFT_GROW_TO_MAX_WIDTH;
		static const fft_output_order_enum
		output_data_order=SSR_FFT_NATURAL;
		static const int twiddle_table_word_length=18;
		static const int twiddle_table_intger_part_length=2;
	};

4. Call 1-D SSR FFT as follows:

.. code-block:: cpp


      fft<params_fix>(inD,outD);
      //OR   
      fft<params_fix,IID>(inD,outD);
      // IID: is a constant giving instance ID


where inD and outD are 2-dimensional complex arrays of ap_fixed, float or double type,
synthesis and simulation use is already explained in the previous table. The I/O arrays can be
declared as follows:

**Fixed Point Type**
First define input type, then using type traits calculate output type
based on ssr_fft_params struct (output type calculation takes in consideration scaling
mode based bit-growth and input bit-widths)
Floating Point 1-D SSR FFT Usage
--------------------------------
The XF 1-D FFT L1 module can be used in a C++ HLS design by:
1- cloning the XF FFT Library git repository and add the following path to compiler include path:

         ``REPO_PATH/xf_fft/L1/include/hw/xf_fft/float/``

2- Include ``xf_fft.hpp``

3- Use namespace ``xf::dsp::fft``

4- Define fft parameter structure lets say call it ``params_float`` by extending ``ssr_fft_default_params`` like :ref:`Defining 1-D FFT Parameter Structure <FLOAT_FFT_PARAMS_STRUCT_LABEL>`

5- call ``fft<params_float>(input_array,output_array)``

Following section gives usage examples and explains some other interface level details for use in C++ based
HLS design.
To use the 1-D SSR FFT L1 module:

1. Include the ``xf_fft.hpp`` header:


.. code-block:: cpp

  #include "xf_fft.hpp.h"

2. Use namespace ``xf::dsp::fft``

.. code-block:: cpp

   using namespace xf::dsp::fft;

3. Define a C++ structure that extends ssr_fft_default_params:

.. code-block:: cpp

   struct params_float:ssr_fft_default_params
   {
      static const int N = 1024;
      static const int R = 4;
      static const fft_output_order_enum output_data_order = SSR_FFT_NATURAL;
      static const transform_direction_enum transform_direction = FORWARD_TRANSFORM;
   };

4. Call 1-D SSR FFT as follows:

.. code-block:: cpp


      fft<params_float>(inD,outD);
      //OR   
      fft<ssr_fft_params,IID>(inD,outD);
      // IID: is a constant giving instance ID


where inD and outD are 2-dimensional complex arrays of ap_fixed, float or double type,
synthesis and simulation use is already explained in the previous table. The I/O arrays can be
declared as follows:

**Fixed Point Type**
First define input type, then using type traits calculate output type
based on ssr_fft_params struct (output type calculation takes in consideration scaling
mode based bit-growth and input bit-widths no relevant for float type)

.. code-block:: cpp

	typedef std::complex< float > I_TYPE;
	typedef xf::dsp::fft::ssr_fft_output_type<ssr_fft_params,I_TYPE>::t_ssr_fft_out O_TYPE;
	I_TYPE inD[SSR_FFT_R][SSR_FFT_L/SSR_FFT_R];
	O_TYPE outD [R][L/R];

Here SSR_FFT_R: define SSR factor and SSR_FFT_L defines the size of FFT transform.

**Float/Double Type**: First define double/float input type, then using type traits calculate output type based on ssr_fft_params struct. For float types the output type calculation will return the same type as input.

.. code-block:: cpp

	typedef std::complex< float/double > I_TYPE;
	typedef hls::ssr_fft::ssr_fft_output_type<ssr_fft_params,I_TYPE>::t_ssr_fft_out O_TYPE;
	I_TYPE inD[SSR_FFT_R][SSR_FFT_L/SSR_FFT_R];
	O_TYPE outD[SSR_FFT_R][SSR_FFT_L/SSR_FFT_R];
	
1-D SSR FFT Input Array Reading and Writing Considerations
----------------------------------------------------------
After synthesis, 1-D SSR FFT HLS IP maps to a streaming block with FIFO interface at both the input
and output, as shown in the following figure:

.. image:: /images/1-ssr_fft_blk_dia.jpg
    :alt: doc tool flow
    :width: 60%
    :align: center

During synthesis, HLS pragmas placed inside IP description will map the 2-dimensions inside the
I/O arrays to time and a wide-stream. It uses the HLS STREAM pragma for the second
dimension. For the first dimension, it uses pragmas for data packing, partitioning and reshaping
to create a single wide stream.
If input and output arrays are declared as the following:

.. code-block:: cpp

	I_TYPE inD[R][L/R];
	O_TYPE outD[R][L/R];

The dimensions with size L/R will be mapped to time and dimension with size R mapped to one
stream which is R-wide. This mapping places some constraints on how these arrays can be read
and written by consumers and producers while writing C++ design using 1-D SSR FFT. These
constraints stem from the physical mapping of array dimensions to time and parallel wide-accesses.
The read and write on 1-D SSR FFT I/O arrays can be performed as follows:

1. The input should be written in a nested loop as follows, with loop accessing the first
dimension to be the inner loop. The outer loop should access the time/2nd dimension:

.. code-block:: cpp

	for( int t=0;t<L/R;t++)
	{
		for (int r=0; r <R : r++)
		{
		inD[r][t] = …… ;
		}
	}

2. The output should be read in a similar fashion as follows:

.. code-block:: cpp

	for( int t=0;t<L/R;t++)
	{
		for (int r=0; r <R : r++)
		{
		….. = outD[r][t] ;
		}
	}

3. If the 1-D SSR FFT IP is facing another HLS IP in the input chain or output chain, the inner loop
doing reading and writing should be unrolled.

1-D SSR FFT Usage in Dataflow Region, Streaming Non-Streaming Connections
-------------------------------------------------------------------------
1-D SSR FFT internally heavily relies on HLS dataflow optimization. The potential use case for 1-D SSR
FFT could interconnect with FFT input or output in two ways:

• Streaming Connection
• Non-Streaming Connections

Streaming Connection
^^^^^^^^^^^^^^^^^^^^
In the case of streaming connection at the input, the scenario should look like as shown in the
following code snippet:	

.. code-block:: cpp

	#pragma HLS DATAFLOW
	in_dummy_proc (..., fft_in);
	fft<ssr_fft_params>(fft_in, fft_out);
	out_dummy_proc(fft_out, ....)
	...
	...
	...

The constraint for input producer is that it should produce a wide stream. The constraint for output consumers is that it should consume a wide stream. These constraints are also described in previous sections.	

Non-Streaming Connection
^^^^^^^^^^^^^^^^^^^^^^^^
The current version of the 1-D SSR FFT does not support non-streaming connection at the output and input. However, it can be enabled by placing adapters at the input/output as required, which can convert stream to different interfaces. For example, the following code snippet is an input adapter that maps streaming interface to memory based interface:


.. code-block:: cpp

	template < type name TYPE, int R, int L >
	void fft_input_adapter (TYPE inData[R][L/R], TYPE outDataStream[R][L/R])
	{
		#pragma HLS INLINE off
		#pragma HLS DATA_PACK variable=inData
		#pragma HLS ARRAY_RESHAPE variable=inData complete dim=1
		for(int t=0; t<L/R; t++)
		{
			#pragma HLS PIPELINE II=1
			for (int r = 0; r< R; ++r)
			{
			outDataStream [r][t] = inData[r][t];
			}
		}
	}

	.
	.
	.

	// Usage of Adapter at input side:
	#pragma HLS DATAFLOW
	in_proc_memory_based(...,in_data_mem_based)
	fft_input_adapter<TYPE_NAME,R,L>(in_data_mem_based,fft_in_stream_based);					 
	hls:ssr_fft::fft<ssr_fft_params>(fft_in_stream_based,fft_out_strema_based);
	out_dummy_proc(fft_out_stream_based, ....)
	...
	...
	...

**Note**: The adapter for the output side can be constructed using a similar method. 
